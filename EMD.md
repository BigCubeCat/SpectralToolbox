# Метод декомпозиции эмпирических мод

## Идея метода 

Мы последовательно выделяем тренды, отнимаем их от композиции и таким образом выделяем несущие частоты.


## [Статья про EMD](http://314159.ru/hht/davydov1.htm)

### Важные этапы алгоритма:

- Построение огибающих через кубические сплайны. [Учебник по вычмату (там алгоритм расчёта сплайнов на 139 странице)](http://www.ict.nsc.ru/matmod/files/textbooks/SharyNuMeth.pdf)<br>
  В программе за сплайны отвечает класс spline. В его конструктор подаются узлы (xs - иксы точек, ys - соответствующие им значения функции)

- После построения верхней и нижней огибающей берем среднее и отнимаем его от сигнала. Итерации останавливаются
либо по заданному параметру, либо когда изменения в сигнале становятся слишком малыми. [В данной статье](https://cyberleninka.ru/article/n/cravnenie-metodov-ostanova-operatsiy-otseivaniya-pri-empiricheskoy-modovoy-dekompozitsii-signalov/viewer)
говорится, что точность обоих методов примерно равна, поэтому для больших объемов данных стоит использовать фиксированное число итераций.
В программе за весь алгоритм отвечает класс decomposer. У него есть поле m_max_iterations которое как раз определяет число итераций для выделения моды.

- Когда мода выделена, он отнимается от начального сигнала. Остаток подвергается новому выделению мод. Этот процесс идёт до тех пор, либо пока мы не возьмём нужное нам число мод, либо пока их вклад (максимальное колебание) не станет меньше порогового значения. В программе за максимальное число мод отвечает поле m_max_result_size, а за порог колебаний отвечает поле m_min_oscillation класса decomposer.

### Частотно временной анализ
- В программе не реализован, но в указанной [статье про emd](http://314159.ru/hht/davydov1.htm) приведен метод Гильберта. Если применить данный метод к каждой выделенной моде, то потом можно будет провести частотно-временной анализ всей композиции.  


